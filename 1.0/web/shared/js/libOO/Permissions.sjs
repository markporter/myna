

/* Class: Myna.Permissions
		A static class that provides access to the Myna Permissions System
		
		Overview:
			The functions and classes in this library combined with the web 
			application located at MynaRoot/myna/permissions/index.ejs form
			Myna's permissions system. The purpose of the permissions system is to
			provide a standardized and centralized system for managing users and 
			their rights in your applications.
		
			First, some standard concepts:
			
			User - 	A "user" is a unique entity such as a human or software 
						service that has certain rights to perform actions in your 
						system. A user can have one or more "logins". Users are a 
						global resource and are not associated with any particular 
						application. 
			
			Login -	A "login" is a unique identifier with an authentication 
						authority, such as a local database, a Microsoft Active 
						Directory, LDAP, or Open ID. Myna knows how to authenticate 
						against its own local database in myna_permissions. To use 
						this functionality, save a user name and password, and set 
						the type to "myna". You can then compare a plain text 
						password to the stored password via <User.isCorrectPassword>. 
			
			Right -	A right is essentially just a name associated with an 
						application (appname). Rights only have meaning when an 
						application checks for them and grants or restricts access 
						based on them. The easiest way to do this is to call 
						<User.hasRight> to check if the logged-in user has a 
						particular right. Myna has some built-in support for the 
						right "edit_permissions" in any application. A user with 
						"edit_permissions" for an application is allowed to edit the 
						permissions for that application in
						MynaRoot/myna/permissions/index.ejs. The Myna Adminstrator 
						can edit permissions for any application, so it is possible 
						to create a user account and assign edit_permissions to it
						and then let that user handle any further changes for his or 
						her application
			
			User Group -		User groups are where users and rights meet. Like 
								rights, user groups are associated with an application 
								(appname). User groups are intended to represent a 
								role, such as "Adminstrators" or "HR Staff". 
			
			Here is the basic process for authentication and authorization:
			
			1) Determine authentication method:
				in this step your application 
				needs to know how to authenticate a user. This can be internal
				Myna authentication via <User.isCorrectPassword>, or an external 
				authentication mechanism such as LDAP or your HR database. Some 
				organizations have multiple ways of authenticating and allow the 
				user to choose which to use.
			
			2)	Set UserID:
				After authentication, look up user's user_id from 
				his/her login and type (<Myna.Permissions.getUserByLogin>) 
				and call <$cookie.setAuthUserId>. This sets a cookie with the user's 
				id and refreshes that cookie  everytime the user makes a request. 
				This cookie is encrypted with the result of 
				<getAuthKey> ("myna_auth_cookie"). There is no timeout for this 
				cookie, but it will automatically expire when the user closes the 
				browser. If you want the authentication token to have a timeout, 
				store the user_id in the session instead.
				
			3) Check Authentication:
				You can confirm that a user has been authenticated by checking 
				<$cookie.getAuthUserId> which will return null if the current user 
				is not authenticated. Placing this check in your 
				<$application.onRequestStart> function is an easy way to prevent 
				unauthenticated access.
				
			4) Check Authorization:
				To see if the current user has the right to "foo", call 
				<User.hasRight> ("foo"). You can use the Myna Administrator to 
				define as a many rights as your application needs
				
			5) Log-out the user:
				To logout, simply call <$cookie.clearAuthUserId> and/or 
				<$session.clear>
				
			Using the Myna Permissions application:
				 The Myna Permissions application is primarily designed to be 
				 accessed through the Myna Administrator and used to set up users,
				 logins, rights, and groups. It can also be used in a simplified form 
				 for a particular application, in which case it is limited to just 
				 group management. In this mode your application can connect to the
				 Myna Permissions application via IFRAME element or window.open() by 
				 passing an authentication token generated by 
				 <Myna.Permissions.getAuthToken>, like this:
				 
			(code)
				<!-- index.ejs -->
				<a href="perms.ejs" target="perm_window">Edit Foo Permissions</a>
				...
				// perms.ejs
				var token =Myna.Permissions.getAuthToken($cookie.getAuthUserId());
				var url = $server.rootUrl + "myna/permissions/index.ejs?appname=foo&auth_token=" + token;
				$res.metaRedirect(url);
			(end)
			
				As an aside, you can use the <getAuthToken> / <consumeAuthToken>
				functions to transfer authentication between any two Myna 
				applications, even if they are on different servers, as long as they 
				both use the same "myna_permissions" datasource. For example, 
				<Myna.WebService> instances check $req.auth_token in addition to the 
				HTTP Basic Auth header, and $cookie.get("myna_auth_cookie") for 
				authentication
		
 */
if (!Myna) var Myna={}
/* ============= Permissions Main  ========================================== */
	Myna.Permissions ={
	/* Function: addApp
			Adds a new application, and returns an instance of 
			<Myna.Permissions.App>. 
			
			Parameters:
				options	-	An object containing the new application's information. 
								See "options" below
								
			Options:
				appname			-	appname of this application. Used programatically 
										to refer to this applicaiton. Only lowercase 
										letters, numbers, and "_" allowed.
				display_name		-	*Optional, default _appname_ *
										The name of the app as it should be displayed to 
										to humans
				description		-	*Optional, default ""*
										A short description of this application
										
			Detail: 
			Creates a new application entry. Also creates a UserGroup called 
			"Administrators" containing a right called "edit_permissions" both 
			associated with this appname. Any users in a group containing this 
			app's "edit_permissions" right will be able to create groups and assign 
			permissions for this app via the Myna permissions front-end. If the 
			appname already exists it is updated with the _display_name_ and 
			_description_.	
		*/
		addApp:function(options){
			options.checkRequired(["appname"]);
			var man = dm.getManager("apps")
			options.inactive_ts=null;
			man.create(options);
			
			var right_id=Myna.Permissions.addRight({
				name:"edit_permissions",
				appname:options.appname,
				description:"Allows users to edit permissions for this application"
			}).right_id;
			
			var group =Myna.Permissions.addUserGroup({
				name:"Administrators",
				appname:options.appname,
				description:"Administrative users"
			});
			group.addRights(right_id);
		},
	
	/* Function: addRight
			adds a new right, and returns an instance of <Myna.Permissions.Right>
		
			Parameters:
				options	-	An object containing the new right's information. See 
								"options" below
								
			Options:
				name				-	Name of the right. Should be a single word.
				appname			-	appname of application associated with this right
				description		-	*Optional, default ""*
										A description of the ability this right confers 
				
		*/
		addRight:function(options){
			options.checkRequired(["name","appname"]);
			var 
				bean,
				dm = new Myna.DataManager("myna_permissions"),
				right_manager = dm.getManager("rights"),
				exists = right_manager.findBeans({
					name:options.name,
					appname:options.appname
				})
			;
			 
			if (exists.length) {
				bean =exists[0];
			} else {
				bean = right_manager.create({
					right_id:Myna.createUuid(),
					name:options.name,
					appname:options.appname,
					description:options.description|| ""
				})
			}
			var right= new Myna.Permissions.Right(bean);
			
			return right;
		},
	/* Function: deleteRight
			deletes a right
		
			Parameters:
				right_id	-	id of right to delete
		*/
		deleteRight:function(right_id){
			if (typeof right_id == "string" && right_id.length ){
				new Myna.Query({
					ds:"myna_permissions",
					sql:<ejs>
						delete from rights
						where right_id = {id}
					</ejs>	,
					values:{
						id:right_id
					}
				})
			}
		},
	/* Function: addUserGroup
			adds a new user group, and returns an instance of <Myna.UserGroup>
		
			Parameters:
				options	-	An object containing the new user group's information. See 
								"options" below
								
			Options:
				name				-	Name of the user group. Can be any string, but 
										should be short
				appname			-	appname of application associated with this right
				
				description		-	*Optional, default ""*
										A description of types of users that 
										should be associated with this group 
				
		*/
		addUserGroup:function(options){
			options.checkRequired(["name","appname"]);
			var dm = new Myna.DataManager("myna_permissions");
			
			var user_group_manager = dm.getManager("user_groups");
			var bean;
			var exists =user_group_manager.findBeans({
				name:options.name,
				appname:options.appname
			})
			
			if (exists.length){
				bean=exists[0];
			} else {
				bean=user_group_manager.create({
					user_group_id:Myna.createUuid(),
					name:options.name,
					appname:options.appname,
					description:options.description|| ""
				})
			}
			
			var user_group= new Myna.Permissions.UserGroup(bean);
					
			return user_group;
		},
	/* Function: deleteUserGroup
			removes a user group
		
			Parameters:
				user_group_id	-	id of group to delete
		*/
		deleteUserGroup:function(user_group_id){
			if (typeof user_group_id == "string" && user_group_id.length ){
				new Myna.Query({
					ds:"myna_permissions",
					sql:<ejs>
						delete from user_groups
						where user_group_id = {id}
					</ejs>	,
					values:{
						id:user_group_id
					}
				})
			}
		},
	/* Function: addUser
			adds a new user, and returns an instance of <Myna.Permissions.User>
		
			Parameters:
				options	-	An object containing the new user's information. See 
								"options" below
								
			Options:
				first_name		-	*Optional, default ""* 
									User's first name
				middle_name	-	*Optional, default ""* 
									User's middle name
				last_name		-	*Optional, default ""* 
									User's last name
				email			-	*Optional, default ""* 
									User's email address
				title			-	*Optional, default ""* 
									User's title, e.g. Mr, Mrs, Sir, Dr
		*/
		addUser:function(options){
			var dm = new Myna.DataManager("myna_permissions");
			
			var manager = dm.getManager("users");
			return new Myna.Permissions.User(manager.create({
				user_id:options.user_id||Myna.createUuid(),
				first_name:options.first_name|| "",
				middle_name:options.middle_name|| "",
				last_name:options.last_name|| "",
				title:options.title|| "",
				country:options.country || "",
				dob:options.dob || null,
				email:options.email || "",
				gender:options.gender || "",
				language:options.language || "",
				nickname:options.nickname || "",
				postcode:options.postcode || "",
				timezone:options.timezone || "",
				created:new Date()
			}))
		},
	/* Function: consumeAuthToken
			returns associated user_id or null if invalid
			
			Parameters:
				token	-	token to consume
				
			Note:
				Consuming a token permenantly removes it. 
				
			See <getAuthToken>
				
 		*/
		consumeAuthToken:function(token){
			var qry =new Myna.Query({
					ds:"myna_permissions",
					sql:<ejs>
						select user_id
						from tokens
						where token = {token}
							and expires >= {now:timestamp}
					</ejs>,
					values:{
						token:token,
						now:new Date(),
					}
			})
			var user_id=null;
			if (qry.data.length) {
				user_id= qry.data[0].user_id;
			} else {
				Myna.log("AUTH","Failed authToken request",Myna.dump(token,"Token") +Myna.dump(qry,"Token Query"));	
			}
			//clear this token as well as any expired tokens 
			new Myna.Query({
				ds:"myna_permissions",
				sql:<ejs>
					delete
					from tokens
					where token = {token} or expires < {now:timestamp}
				</ejs>,
				values:{
					token:token,
					now:new Date()
				}
			})
			
			return user_id;
		},
	/* Function: getAuthAdapter
			creates and configures and authentication adepter based on the 
			_config_ name provided  
			
			Parameters:
				config		-	name of the configuration to use to create the 
								adapter. This name should match a config file in 
								/WEB-INF/myna.auth_types
			
		*/
		getAuthAdapter:function(name){
			if (!/^[^~]+$/.test(name)) {
				throw new Error("Invalid adapter name '"
				+ name
				+"'. Adapter names cannot contain tilde(~) characters");
			}
			var adapter = $server.get("MYNA_auth_adapter_" + name);
			if (!adapter){
				adapter = {
			   config:new Myna.File("/WEB-INF/myna/auth_types/" + name).readString().parseJson()
			}
				Myna.include("/shared/js/libOO/auth_adapters/" + adapter.config.adapter +".sjs",adapter);
				$server.set("MYNA_auth_adapter_" + name,adapter);
			}
			return adapter;
		},
	/* Function: getAuthKey
			retrieves a unique authKey from the crypt_keys table for the supplied 
			name, or creates one if the name does not exist.  
			
			Parameters:
				name	-	name of key to retrieve
			
		*/
		getAuthKey:function(name){
			name = String(name).toLowerCase();
			try {
				var manager = new Myna.DataManager("myna_permissions").getManager("crypt_keys");
				if (!manager.find(name).length){
					manager.create({
						name:name,
						created:new Date(),
						key:Myna.createUuid().toHash()
					})
				}
				return manager.getById(name).get_key();
			} catch(e){
				
				try{
					Myna.log("ERROR","Error accessing permissions database from Myna.Permissions.getAuthKey",Myna.formatError(__exception__));
				} catch(e2){}
				var localKeysFile = new Myna.File("/WEB-INF/myna/localKeys");
				if (localKeysFile.exists()){
					var localKeys = localKeysFile.readString().parseJson();
				} else {
					localKeys = {};
					localKeys[name] = Myna.createUuid().toHash();
					localKeysFile.writeString(localKeys.toJson())
				}
				return localKeys[name]
			}
		},
	/* Function: getAuthToken
			creates stores and return a one-use authentication token for the 
			supplied user_id  
			
			Parameters:
				user_id	-	user_id of the user to be authenticated
				timeout	-	*Optional, default 10000* 
								Time in milliseconds that this token will be accepted. 
								This should be the smallest amount of time that the two 
								systems can reliably process. Longer timeouts leave a 
								larger window for replay attacks  
			Detail:
				This function is intended to be used in conjunction with 
				<consumeAuthToken> to allow an application to "pre-authenticate"
				a user to another application. This requires the source application 
				to acquire an authentication token representing a user_id, and then 
				send this to the target application, normally via a URL or FORM 
				variable called "auth_token". The receiving application will call
				<consumeAuthToken> and store the result with <$cookie.setAuthUserId>
								
				Authentication tokens are stored in the "myna_permissions" data
				source, so both sending and receiving applications must use the same 
				database for "myna_permissions".
				
				The token itself does not contain any authentication information. It
				is a just a cryptographically unique key to lookup authentication 
				information in a shared database. If these tokens are sent over  
		*/
		getAuthToken:function(user_id,timeout){
			if (!timeout) timeout = 10;
			var expires = new Date().add(Date.SECOND,timeout);
			var token  = Myna.createUuid().toHash();
			new Myna.Query({
					ds:"myna_permissions",
					sql:<ejs>
						insert into tokens(user_id,token,expires) values(
							{user_id},
							{token},
							{expires:TIMESTAMP}
						)
					</ejs>,
					values:{
						user_id:user_id,
						token:token,
						expires:expires
					}
			})
			return token;
		},
	/* Function: getAuthTypes
			returns an array of valid auth type names for this system
		*/
		getAuthTypes:function(){
			return new Myna.File("/WEB-INF/myna/auth_types")
				.listFiles()
				.valueArray("fileName")
				.filter(function(name){
					return /^[^~]+$/.test(name)
				})
		},
	
	/* Function: getRightById
			returns the right object that matches the supplied id or null
			
			Parameters:
				id		-	right id to search
		*/
		getRightById:function(id){
			if (!id || typeof id != "string") return null
			var dm = new Myna.DataManager("myna_permissions");
			var manager = dm.getManager("rights"); 
			var exists = manager.find(id).length;
			
			if (exists) {
				return new Myna.Permissions.Right(manager.getById(id));
			} else {
				return null;	
			}
		},
	/* Function: getRightByName
			returns the right object that matches the supplied name and appname, or 
			returns null
			
			Parameters:
				name		-	right name
				appname	-	right appname
		*/
		getRightByName:function(name,appname){
			var dm = new Myna.DataManager("myna_permissions");
			var manager = dm.getManager("rights"); 
			var exists = manager.find({
				name:name,
				appname:appname	
			});
			
			if (exists.length) {
				return new Myna.Permissions.getRightById(exists[0]);
			} else {
				return null;	
			}
		},	
	/* Function: getRightsByAppname
		returns a <Myna.DataSet> of all the rights associated with the 
		supplied appname
			
			Parameters:
				appname		-	appname to filter by
		*/
		getRightsByAppname:function(appname){
			var beans = new Myna.DataManager("myna_permissions").getManager("rights")
			.findBeans({appname:appname}).map(function(bean){
				return new Myna.Permissions.Right(bean)
			})
			return beans;
		},
	/* Function: getUserGroupsByAppname
		returns a <Myna.DataSet> of all the user groups associated with the 
		supplied appname
			
			Parameters:
				appname		-	appname to filter by
		*/
		getUserGroupsByAppname:function(appname){
			return new Myna.DataManager("myna_permissions").getManager("user_groups")
			.findBeans({appname:appname}).map(function(bean){
				return new Myna.Permissions.UserGroup(bean)
			})
		},
		
	/* Function: getUserGroupById
			returns the user group object that matches the supplied id or null
			
			Parameters:
				id		-	user group id to search
		*/
		getUserGroupById:function(id){
			if (!id || typeof id != "string") return null
			var dm = new Myna.DataManager("myna_permissions");
			var manager = dm.getManager("user_groups"); 
			var exists = manager.find(id).length;
			
			if (exists) {
				return new Myna.Permissions.UserGroup(manager.getById(id));
			} else {
				return null;	
			}
		},
	/* Function: getUserById
			returns the User object that matches the supplied id or null
			
			Parameters:
				id		-	user id to search
		*/
		getUserById:function(id){
			var $this= this;
			if (!id){
				throw new Error("Myna.Permissions.User.getUserById: id is required") 	
			}
			var dm = new Myna.DataManager("myna_permissions");
			
			var users = dm.getManager("users");
			
			if (users.find(id).length){
				return new Myna.Permissions.User(users.getById(id))
			} else{
				return null;	
			}
		},
	/* Function: getUserByLogin
			returns the User object that matches the supplied login or null
			
			Parameters:
				type		-	login type
				login		-	login
		*/
		getUserByLogin:function(type,login){
			var dm = new Myna.DataManager("myna_permissions");
			
			var manager = dm.getManager("users");
			var qryUser = new Myna.Query({
				ds:"myna_permissions",
				sql:<ejs>
					select users.user_id 
					from users,
						user_logins
					where
						users.user_id = user_logins.user_id
						and type={type}
						and login={login}
				</ejs>,
				values:{
					type:type,
					login:login
				}
			});
			
			if (qryUser.data.length){
				return new Myna.Permissions.User(manager.getById(qryUser.data[0].user_id))
			} else{
				return null;	
			}
		},
	/* Function: getUserByAuth
			returns the <User> that matches the supplied username and password 
			or null if no matches
			
			Parameters:
				login		-	login string (username)
				password	-	user's password
				type		-	*Optional, default null*
								auth type to check, or all types if not defined. 
								if more than one user matches this login and 
								password an exception is thrown
				
		*/
		getUserByAuth:function(login,password,type){
			var $this=Myna.Permissions;
			var types=type?[type]:$this.getAuthTypes()
			var user_ids=[];
			
			types.forEach(function(type){
				var adapter =Myna.Permissions.getAuthAdapter(type);
				
				if (adapter.isCorrectPassword(login,password)){
					if (type == "server_admin") {
						user_ids.push("myna_admin");
						return;
					}
					
					var user =$this.getUserByLogin(type,login);
					if (!user){
						if (type == "myna") throw new Error("Attempt to create duplicate user")
						user = $this.addUser(adapter.getUserByLogin(login))
						user.setLogin({type:type,login:login})
					}
					user_ids.push(user.get_user_id());
				}
			})
			var failKey = "failed_logins_" + login +"/"+type;
			if (!$server.get(failKey)) $server.set(failKey,0);
			var failedAttempts =$server.get(failKey); 
			if (user_ids.length==1) {
				Myna.sleep(Date.getInterval("s",Math.min(failedAttempts*5,25)));
				$server.set(failKey,0);
				return $this.getUserById(user_ids[0]);
			} else if (user_ids.length==0){
				$server.set(failKey,++failedAttempts);
				$req.timeout=(failedAttempts+1)*5;
				Myna.sleep(Date.getInterval("s",failedAttempts*5));
				Myna.log("AUTH","Failed authentication for user " + login +"/"+type );
				return null;
			} else {
				var msg="duplicate users ("+userId.join()+") for login '" + login+ "'";
				throw new Error(msg)
			}
		}
		
	}

/* ============= Permissions User  ========================================== */
	/* Class: Myna.Permissions.User
		Provides access to user specific permissions. see <Myna.Permissions> for 
		creation
	 */
	
	Myna.Permissions.User = function(dao){
		this.dao = dao;
		dao.data.setDefaultProperties({
			first_name:"",
			middle_name:"",
			last_name:""
		},true)
		//copy properties to this 
		dao	.applyTo(this);
		//get rid of set_user_id. It is unnecessary and dangerous
		delete this.set_user_id
		//copy user properties to this object
		dao.data.applyTo(this)
	}
	/* Function: get_created
		returns created
	 */ 
	/* Function: get_first_name
		returns first_name
	 */ 
	/* Function: get_last_login
		returns last_login
	 */ 
	/* Function: get_last_name
		returns last_name
	 */ 
	/* Function: get_middle_name
		returns middle_name
	 */ 
	/* Function: get_title
		returns title
	 */ 
	/* Function: get_user_id
		returns user_id
	 */ 
	/* Function: set_created
		sets created
		
		Parameters:
			value	-	new value
	 */
	/* Function: set_first_name
		sets first_name
		
		Parameters:
			value	-	new value
	 */
	/* Function: set_last_login
		sets last_login
		
		Parameters:
			value	-	new value
	 */
	/* Function: set_last_name
		sets last_name
		
		Parameters:
			value	-	new value
	 */
	/* Function: set_middle_name
		sets middle_name
		
		Parameters:
			value	-	new value
	 */
	/* Function: set_title
		sets title
		
		Parameters:
			value	-	new value
	 */
	/* Function: qryRights
		returns query of rights associated with this group
		
	 */
		Myna.Permissions.User.prototype.qryRights = function(){
			var ug = this;
			return new Myna.Query({
				ds:ug.ds,
				sql:<ejs>
					select ar.* 
					from assigned_rights ar,
						user_group_members ugm
					where ugm.user_group_id=ar.user_group_id
						and user_id={id}
				</ejs>	,
				values:{id:ug.get_user_id()}
			})
		}
	
	/* Function: inactivate
		inactivates this user. Inactivating a user also removes the user from all
		user groups and causes isCorrectPassword to fail even if the password is 
		correct
		
	 */
		Myna.Permissions.User.prototype.inactivate = function(){
			var u = this;
			var now = new Date();
			u.set_inactive_ts(now)
			
			new Myna.Query({
				ds:u.ds,
				sql:<ejs>
					delete from user_group_members 
					where user_id ={id}
				</ejs>	,
				values:{
					id:u.get_user_id()
				}
			})
		}
	/* Function: isActive
		returns true if this user is active
		
	 */
		Myna.Permissions.User.prototype.isActive = function(){
			return !(this.get_inactive_ts() instanceof Date);
		}
	/* Function: reactivate
		reactivates this user
		
	 */
		Myna.Permissions.User.prototype.reactivate = function(){
			var u = this;
			u.set_inactive_ts(null);
			
		}
	
	
	/* Function: hasRight
		returns true if this user has been assigned the supplied appname and right name
		
		Parameters:
			appname		-	name appname of of application
			right		-	right name
	 */
		Myna.Permissions.User.prototype.hasRight = function(appname,rightName){
			var ug = this;
			//the admin user has all rights to the myna_admin application even 
			//if the database is broken
			if (
				this.user_id == "myna_admin" &&
				appname == "myna_admin"
			) {return true;}
			
			return new Myna.Query({
				ds:ug.ds,
				sql:<ejs>
					select 'x' 
					from 
						rights r,
						assigned_rights ar,
						user_group_members ugm
					where 1=1
						and r.right_id = ar.right_id
						and ugm.user_group_id=ar.user_group_id
						and user_id={id}
						and appname={appname}
						and name={rightName}
				</ejs>	,
				values:{
					id:ug.get_user_id(),
					appname:appname,
					rightName:rightName
				}
			}).data.length
		}
	/* Function: getLogins
		returns an array of objects in the form of [{type,login}] of the logins 
		associated with this user
	 */
		Myna.Permissions.User.prototype.getLogins = function(){
			var user = this;
			return new Myna.Query({
				ds:this.dao.ds,
				sql:<ejs>
					select type,login
					from user_logins
					where user_id={user_id}
				</ejs>,
				values:{
					user_id:user.get_user_id()
				},
			}).data;
		}
	/* Function: getLoginList
		returns a list of type/login pairs in the form of "type:login,type:login" of 
		the logins associated with this user
		
		Parameters:
			delimiter		-		*Optional, default ','*
									seperator between each type/login set
			seperator		-		*Optional, default ':'*
									seperator between each type and login in each login set
	 */
		Myna.Permissions.User.prototype.getLoginList = function(delimiter,seperator){
			var user = this;
			if (!delimiter) delimiter = ",";
			if (!seperator) seperator = ":";
			return new Myna.Query({
				ds:this.dao.ds,
				sql:<ejs>
					select type,login
					from user_logins
					where user_id={user_id}
				</ejs>,
				values:{
					user_id:user.get_user_id()
				},
			}).data.map(function(e){
				return e.type + seperator + e.login
			}).join(delimiter);
		}
	
	/* Function: setLogin
		adds or updates an login for this user
		
		Parameters:
			options	-	An object that conains the options for this login. see below
			
		Options:
			type		-	type of login. This is a hint for how to authenticate using 
							this login. Suggested values: myna (for local password 
							access), ldap, openid
			login		-	the appropriate type of identifier,
			password	-	*optional default ""*
							a plain text password to encrypt with this login
	 */
		Myna.Permissions.User.prototype.setLogin = function(options){
			var user = this;
			var dm = new Myna.DataManager("myna_permissions");
			var user_logins = dm.getManager("user_logins");
			
			options.user_id = user.get_user_id();
			if ("password" in options){
				options.password =options.password.toHash();
			} else {
				options.password = ""	
			}
			var existing =user_logins.find({
				user_id:options.user_id,
				type:String(options.type),
				login:String(options.login)
			})
				
			if (existing.length){
				user_logins.getById(existing[0]).set_password(options.password)
			} else {
				options.user_login_id = Myna.createUuid();
				user_logins.create(options)
			}
		}
	/* Function: isCorrectPassword
			returns true if the supplied user login and plaintext password match 
			the stored password hash. Only works for "myna" auth type. Will 
			always return false for inactive users 
			
			Parameters:
				login		-	user login 
				password	-	a plain text password for comparison
		*/
		Myna.Permissions.User.prototype.isCorrectPassword=function(login,password){
			var user = this;
			if (!user.isActive()) return false;
			var dm = new Myna.DataManager("myna_permissions");
			var user_logins = dm.getManager("user_logins");
			
			if (!password ) password = "";	
				
			var existing =user_logins.find({
				user_id:user.get_user_id(),
				type:"myna",
				login:login
			})
				
			if (existing.length){
				return password.hashEquals(user_logins.getById(existing[0]).get_password());
			} else {
				return false;
			}
		}
/* ============= Permissions Right  ========================================= */
	/* Class: Myna.Permissions.Right
		Provides access to Right specific actions. see <Myna.Permissions> for 
		creation
	 */
	 
	/* Function: get_appname
		returns appname
	 */ 
	/* Function: get_description
		returns description
	 */ 
	/* Function: get_name
		returns name
	 */ 
	/* Function: get_right_id
		returns right_id
	 */ 
	/* Function: set_appname
		sets appname
		
		Parameters:
			value	-	new value
	 */
	/* Function: set_description
		sets description
		
		Parameters:
			value	-	new value
	 */
	/* Function: set_name
		sets name
		
		Parameters:
			value	-	new value
	 */
		Myna.Permissions.Right = function(dao){
			this.dao = dao;
			//copy properties to this 
			dao	.applyTo(this);
			//get rid of set_right_id. It is unnecessary and dangerous
			delete this.set_right_id;
		}

/* ============= Permissions UserGroup  ===================================== */
	/* Class: Myna.Permissions.UserGroup
		Provides access to user group specific actions. See <Myna.Permissions> for 
		creation
	 */
	Myna.Permissions.UserGroup = function(dao){
		this.dao = dao;
		//copy properties to this 
		dao	.applyTo(this);
		//get rid of set_user_group_id. It is unnecessary and dangerous
		delete this.set_user_group_id ;
	}

	/* Function: get_appname
		returns appname
	 */ 
	/* Function: get_description
		returns description
	 */ 
	/* Function: get_name
		returns name
	 */ 
	/* Function: get_user_group_id
		returns user_group_id
	 */
	
	/* Function: set_appname
		sets appname
		
		Parameters:
			value	-	new value
	 */
	/* Function: set_description
		sets description
		
		Parameters:
			value	-	new value
	 */
	/* Function: set_name
		sets name
		
		Parameters:
			value	-	new value
	 */
	
	/* Function: addUsers
		adds one or more users to this group, if not already added
		
		Parameters:
			user_id_list		-	array or list of user_ids to add
			
	 */
		Myna.Permissions.UserGroup.prototype.addUsers = function(user_id_list){
			var ugm = this.dm.getManager("user_group_members");
			if (!(user_id_list instanceof Array)){
					user_id_list = user_id_list.split(/,/)
			}
			var ug = this;
			user_id_list.forEach(function(user_id){
				var existing = ugm.find({
					user_group_id:ug.get_user_group_id(),
					user_id:user_id
				})
				if (!existing.length){
					ugm.create({
						user_group_member_id:Myna.createUuid(),
						user_group_id:ug.get_user_group_id(),
						user_id:user_id
					})
				}
			})
		}
	
	
	/* Function: addRights
		adds one or more rights to this group, if not already added
		
		Parameters:
			right_id_list		-	array or list of right_ids of rights to add
			
	 */
		Myna.Permissions.UserGroup.prototype.addRights = function(right_id_list){
			var assigned_rights = this.dm.getManager("assigned_rights");
			if (!(right_id_list instanceof Array)){
				right_id_list = right_id_list.split(/,/)
			}
			var ug = this;
			right_id_list.forEach(function(right_id){
				var existing = assigned_rights.find({
					user_group_id:ug.get_user_group_id(),
					right_id:right_id
				})
				if (!existing.length){
					assigned_rights.create({
						assigned_rights_id:Myna.createUuid(),
						user_group_id:ug.get_user_group_id(),
						right_id:right_id
					})
				}
			})
		}
	
	/* Function: qryRights
		returns query of rights associated with this group
		
	 */
		Myna.Permissions.UserGroup.prototype.qryRights = function(){
			var ug = this;
			return new Myna.Query({
				ds:ug.ds,
				sql:<ejs>
					select * 
					from assigned_rights
					where user_group_id={id}
				</ejs>	,
				values:{id:ug.get_user_group_id()}
			})
		}
	
	/* Function: removeRights
		removes one or more rights from this group, if not already removed
		
		Parameters:
			right_id_list		-	array or list of right_ids of user to add
			
	 */
		Myna.Permissions.UserGroup.prototype.removeUsers = function(right_id_list){
			if (right_id_list instanceof Array){
				right_id_list = right_id_list.join();
			}
			var ug = this;
			new Myna.Query({
				ds:this.ds,
				sql:<ejs>
					delete from assigned_rights 
					where right_id in ({list})
						and user_group_id = {id}
				</ejs>,
				values:{
					list:right_id_list,
					id:ug.get_user_group_id()
				}
			})
			
		}
	
	/* Function: removeUsers
		removes one or more users from this group, if not already removed
		
		Parameters:
			user_id_list		-	array or list of user_ids of user to add
			
	 */
		Myna.Permissions.UserGroup.prototype.removeUsers = function(user_id_list){
			if (user_id_list instanceof Array){
				user_id_list = user_id_list.join();
			}
			var ug = this;
			new Myna.Query({
				ds:this.ds,
				sql:<ejs>
					delete from user_group_members 
					where user_id in ({list})
						and user_group_id = {id}
				</ejs>,
				values:{
					list:user_id_list,
					id:ug.get_user_group_id()
				}
			})
			
		}
	
	
	/* Function: qryUsers
		returns a query of user information associated with this group
		
	 */
		Myna.Permissions.UserGroup.prototype.qryUsers = function(){
			var ug = this;
			return new Myna.Query({
				ds:ug.ds,
				sql:<ejs>
					select u.* 
					from 
						users u,
						user_group_members ugm
					where u.user_id = ugm.user_id
						and ugm.user_group_id = {id}
				</ejs>,
				values:{id:ug.get_user_group_id()}
			})
		}


